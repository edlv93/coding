# 常用术语

- ESB（Enterprise Service Bus）企业服务总线：一个实现系统间集成和互联互通的重要技术架构，可以理解为是一种消息和服务集成的中间件平台
- 

# 一、树

## 1.1 基本概念

- 树有多个节点(node)，用以储存元素
- 节点之间的连线称为边(edge)
- 边的上端节点称为父节点
- 下端称为子节点
- 树的深度(depth)是从根节点开始（其深度为1）自顶向下逐层累加的
- 高度的定义为：从结点x向下到某个叶结点**最长简单路径**中**边的条数**
- 深度是从根节点往下

## 1.2 二叉树

常见的二叉树：完全二叉树，满二叉树，二叉搜索树，二叉堆，AVL 树，红黑树，哈夫曼树

- 完全二叉树：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边（效率高）

- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树

- 二叉搜索树（二叉排序树，二叉查找树）

  - 树中每个节点最多有两个子树，通常称为左子树和右子树
  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
  - 它的左右子树仍然是一棵二叉搜索树 (recursive)

- 平衡树(B树)

  - 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
  - 子节点数：1<非叶节点的子节点数<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）
  - 关键字数：ceil(m/2)-1<=枝节点的关键字数量<=M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
  - 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子

- B+树

  - 特点

    - B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引（**非叶子**节点所能保存的关键字大大增加）
    - B+树**叶子**节点保存父节点的所有关键字记录的指针，数据地址必须要到叶子节点才能获取到（每次数据查询的次数都一样）
    - B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针
    - 非叶子节点的子节点数=关键字数（两种实现，或：非叶节点的关键字数=子节点数-1。Mysql 的B+树是第一种）

  - 与红黑树的比较（访问磁盘数据有更高的性能）

    - B+ 树有更低的树高

    - 磁盘访问原理：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

      如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取

    - 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入

- 平衡二叉树（AVL 树）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

- 红黑树

  - **黑色完美平衡**：任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点

## 1.3 前缀树（字典树）

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

- 指向子节点的指针数组 children。例如，数组长度为626，即小写英文字母的数量。此时children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。
- 布尔字段 isEnd，表示该节点是否为字符串的结尾。

# 二、Linux

## 2.1 VIM 三个模式

	- 一般指令模式（默认模式）
	- 编辑模式
	- 指令列模式

## 2.2 文件属性

- 用户分为三种
  - 文件拥有者
  - 群组
  - 其它人
- 文件类型
  - d：目录
  - -：文件
  - l：链接文件
- 文件权限：
  - 三位一组
  - 对文件拥有者、所属群组以及其它人的文件权限
  - 3 位分别为 r、w、x 权限，表示可读、可写、可执行
- 文件时间
  - modification time (mtime)：文件的内容更新就会更新；
  - status time (ctime)：文件的状态（权限、属性）更新就会更新；
  - access time (atime)：读取文件时就会更新。
- 修改权限
  - chmod
  - 左到右每个位的权值为 4、2、1
- 默认权限
  - 文件默认权限666
  - 目录默认权限777

## 2.3 链接

- 实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。
- 符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式
- ln创建链接：默认是实体链接，加 -s 为符号链接

![image-20210315153144493](/Users/lv/Library/Application Support/typora-user-images/image-20210315153144493.png)

## 2.4 获取文件内容

- cat、tac(从最后一行打印)
- more（一页一页打印）、less（增加向前翻页）
- head（前n行）、tail（后几行）

## 2.5 数据流重定向

- 一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向
- 输出重定向到 /dev/null（扔进垃圾箱）

## 2.6 排序指令（sort）

```shell
$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间

$ uniq [-ic](可以将重复的数据只取一个)
-i ：忽略大小写
-c ：进行计数
```

## 2.7 正则表达式(grep)

```shell
$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
```

## 2.8 查看进程

- ps -l 查看自己的进程
- ps aux 查看系统所有进程
- pstree 查看进程数

# 三、Java

## 3.1 基本数据类型

- 整型：byte(8)、short(16)、int(32)、long(64)
- 浮点型：float(32)、double(64)
- 布尔型：boolean(8)
- 字符型：char(16)
- 只能向上转型
-  += 或者 ++ 运算符会执行隐式类型转换

## 3.2 异常处理

![image-20210316103655281](/Users/lv/Library/Application Support/typora-user-images/image-20210316103655281.png)

## 3.3 三种类型的异常

- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

### 3.3.1 关键字

- try/catch：捕获异常，catch可以多重捕获（直到异常被捕获或者通过所有的 catch 块）
- throws/throw：方法使用 throws 关键字来声明（一个方法没有捕获到一个检查性异常），throw 关键字抛出一个异常
- finally：在 try 代码块后面执行的代码块

### 3.3.2 自定义异常

- 所有异常都必须是 Throwable 的子类。
- 自定义检查性异常类，需要继承 Exception 类。
- 自定义运行时异常类，那么需要继承 RuntimeException 类。

## 3.4 hashMap

- 底层数据结构，JDK 1.8 是**数组 + 链表 + 红黑树**，JDK 1.7 无红黑树。
- 初始容量为 **16**，通过 tableSizeFor 保证容量为 2 的幂次方。寻址方式，高位异或，**(n-1)&h** 取模，优化速度。
- 扩容机制，当元素数量大于容量 x 负载因子 0.75 时，容量扩大为原来的 2 倍，新建一个数组，然后转移到新数组。
- 基于 Map 实现。
- 线程不安全。
- key的hashCode()做hash，然后再计算index(高位运算和取模运算)
- 指针数组，value为链表，长度大于 8 时，转化为红黑树（1.8），优化查询效率。
  - 当 HashMap 中有大量的元素都存放到同一个桶中时，这个时候 HashMap 就相当于一个单链表，遍历时间复杂度就是 O(n)
  - 转换为红黑树：时间复杂度为 O(logn)
- 当限制n为2的幂次方时，**(n-1)&h**和h%n结果一致，但效率高了很多倍

![image-20210310173600017](/Users/lv/Library/Application Support/typora-user-images/image-20210310173600017.png)

![image-20210310174131957](/Users/lv/Library/Application Support/typora-user-images/image-20210310174131957.png)

## 3.5 ConcurrentHashMap(待完善)

- 采用了数组+链表+红黑树的实现方式来设计
- ConcurrentHashMap的主干是个Segment数组
  - Segment继承了ReentrantLock，重入锁
  - Segment类似于HashMap，一个Segment维护着一个HashEntry数组
- 分段锁
- 内部大量采用CAS操作
  - 比较交换
  - 乐观锁
  - 包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)
- 链表：保存key，value及key的hash值的数据结构，value和next都用volatile修饰

## 3.6 final关键字

- 修饰类不能被继承
- 修饰方法：不能被重写
- 修饰变量：基本数据类型不能被修改；引用类型初始化后不能指向另一个对象

## 3.7 String实现

- 属性value：char[]
- String不可变：
  - 实现字符串池（String pool）
  - 多线程安全
  - 避免安全问题
  - 加快字符串处理速度（hashMap的key方便计算hashcode）
- Equals:
  - this == anObject
  - anObject instanceof String
  - 比较value属性
  - 重写hashCode方法

## 3.8 clone

- clone() 是 Object 的 protected 方法，不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
- Cloneable 接口规定：一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException
- 浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象
- 深拷贝：拷贝对象和原始对象的引用类型引用不同对象
- 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象

## 3.9 volatile

- 在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，**在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。**
- 禁止 JVM 指令重排序。

![image-20210311142812437](/Users/lv/Library/Application Support/typora-user-images/image-20210311142812437.png)

## 3.10 synchronized

- 三种应用方式：
  - 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
  - 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
  - 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

## 3.11 JAVA锁类型

偏向锁，自旋锁，轻量级锁（乐观锁）重量级锁（悲观锁）

- 通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。
- 需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。

![image-20210318145724987](/Users/lv/Library/Application Support/typora-user-images/image-20210318145724987.png)

## 3.12 AQS

一个用来构建锁和同步器的框架

- 结构
  - 用 volatile 修饰的整数类型的 state 状态（持有锁的次数），用于表示同步状态，提供 getState 和 setState 来操作同步状态；
  - 提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心；
  - AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法。
- 独占锁模式
  - 用 state 值表示锁并且 0 表示无锁状态，0 -> 1 表示从无锁到有锁，
  - 仅允许一条线程持有锁，其余的线程会被包装成一个 Node 节点放到队列中进行挂起
  - 队列中的头节点表示当前正在执行的线程，当头节点释放后会唤醒后继节点
- 共享锁模式
  - 当有一个线程获取到锁之后，那么它就会依次唤醒等待队列中可以跟它共享的节点

## 3.13 ReentrantLock

- 基于 AQS （AbstractQueuedSynchronizer）实现，主要有 state (资源) + FIFO (线程等待队列) 组成。
- 公平锁与非公平锁：区别在于在获取锁时，公平锁会判断当前队列是否有正在等待的线程，如果有则进行排队。
- 使用 lock() 和 unLock() 方法来加锁解锁。
- 非公平锁吞吐量高
  在获取锁的阶段来分析，当某一线程要获取锁时，非公平锁可以直接尝试获取锁，而不是判断当前队列中是否有线程在等待。一定情况下可以避免线程频繁的上下文切换，这样，活跃的线程有可能获得锁，而在队列中的锁还要进行唤醒才能继续尝试获取锁，而且线程的执行顺序一般来说不影响程序的运行。

## 3.13 线程池

- 分类
  - FixThreadPool 固定数量的线程池，适用于对线程管理，高负载的系统
  - SingleThreadPool 只有一个线程的线程池，适用于保证任务顺序执行
  - CacheThreadPool 创建一个不限制线程数量的线程池，适用于执行短期异步任务的小程序，低负载系统
  - ScheduledThreadPool 定时任务使用的线程池，适用于定时任务

- 重要参数
  - int corePoolSize, 核心线程数
  - int maximumPoolSize, 最大线程数
  - long keepAliveTime, TimeUnit unit, 超过 corePoolSize 的线程的存活时长，超过这个时间，多余的线程会被回收。
  - BlockingQueue<Runnable> workQueue, 任务的排队队列
  - ThreadFactory threadFactory, 新线程的产生方式
  - RejectedExecutionHandler handler) 拒绝策略

- 线程池线程工作过程

  corePoolSize -> 任务队列 -> maximumPoolSize -> 拒绝策略

> 核心线程在线程池中一直存活，当有任务需要执行时，直接使用核心线程执行任务。当任务数量大于核心线程数时，加入等待队列。当任务队列数量达到队列最大长度时，继续创建线程，最多达到最大线程数。当设置回收时间时，核心线程以外的空闲线程会被回收。如果达到了最大线程数还不能够满足任务执行需求，则根据拒绝策略做拒绝处理。

## 3.14 反射

**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法**

### 3.14.1 常用方法

- 获取反射中的Class对象`Class clz`
  - 使用 Class.forName 静态方法`Class.forName("java.lang.String")`
  - 使用 .class 方法`String.class`
  - 使用类对象的 getClass() 方法`new String("Hello").getClass()`
- 通过反射创建类对象(通过 Constructor 对象创建类对象可以选择特定构造方法，通过 Class 对象则只能使用默认的无参数构造方法)
  - 通过 Class 对象的 newInstance() 方法`(Apple)clz.newInstance()`
  - 通过 Constructor 对象的 newInstance() 方法`Constructor constructor = clz.getConstructor(); Apple apple = (Apple)constructor.newInstance();`
- 通过反射获取类属性、方法、构造器
  - Class 对象的 getFields() 方法可以获取 Class 类的属性（无法获取私有属性）
  - Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性

## 3.15 注解

### 3.15.1 注解的作用

- 由编译器使用的注解：不会被编译进入`.class`文件，在编译后就被编译器扔掉（@Override、@SuppressWarnings）
- 由工具处理.class文件使用的注解：会被编译进入`.class`文件，但加载结束后并不会存在于内存中
- 在程序运行期能够读取的注解：在加载后一直存在于JVM中

### 3.15.2 配置参数

可以有默认值；大部分注解会有一个名为`value`的配置参数，可以省略value参数

- 所有基本类型；
- String；
- 枚举类型；
- 基本类型、String、Class以及枚举的数组

### 3.15.3 定义方式

- 使用`@interface`语法来定义注解
- 用`default`设定一个默认值（强烈推荐）

### 3.15.4 元注解

- 修饰其他注解的注解
- Java标准库定义
- 常用
  - @Target：定义`Annotation`能够被应用于源码的哪些位置（数组）
    - 类或接口：`ElementType.TYPE`；
    - 字段：`ElementType.FIELD`；
    - 方法：`ElementType.METHOD`；
    - 构造方法：`ElementType.CONSTRUCTOR`；
    - 方法参数：`ElementType.PARAMETER`
  - @Retention：定义`Annotation`的生命周期（默认值CLASS）
    - `RetentionPolicy.SOURCE`：在编译期就被丢掉（由编译器使用）
    - `RetentionPolicy.CLASS`：仅保存在class文件中，它们不会被加载进JVM（主要由底层工具库使用）
    - RetentionPolicy.RUNTIME`：会被加载进JVM，并且在运行期可以被程序读取
  - @Repeatabl：定义`Annotation`是否可重复
  - @Inherited：定义子类是否可继承父类定义的`Annotation`

### 3.15.5 使用方式

注解定义后也是一种`class`，所有的注解都继承自`java.lang.annotation.Annotation`。读取注解，需要使用反射API

- `Class.isAnnotationPresent(Class)`
- `Field.isAnnotationPresent(Class)`
- `Method.isAnnotationPresent(Class)`
- `Constructor.isAnnotationPresent(Class)`

## 3.16 动态代理

没有实现类但是在运行期动态创建了一个接口对象的方式，称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理

在运行期动态创建一个`interface`实例的方法如下：

1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；
2. 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：
   1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`；
   2. 需要实现的接口数组，至少需要传入一个接口进去；
   3. 用来处理接口方法调用的`InvocationHandler`实例。
3. 将返回的`Object`强制转型为接口。

## 3.17 Spring

Spring的核心就是提供了一个**IoC容器**，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等

### 3.17.1 IoC原理

- IoC全称Inversion of Control，直译为控制反转（依赖注入）
- 一个高度可扩展的无侵入容器
- 解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期

### 3.17.2 依赖注入方式

- 属性注入
- 构造方法注入

注：允许混合使用

### 3.17.3 AOP

- AOP是Aspect Oriented Programming，即面向切面编程
- Spring的AOP实现就是基于JVM的动态代理
- Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类

# 四、MySQL

## 4.1 数据类型

- 整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间
- 浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型
- 字符串： CHAR（定长） 和 VARCHAR（变长的）
- 时间日期：date、datetime、timestamp（比DATETIME 空间效率更高）

## 4.2 主从复制

- **主**：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中
- **从**：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中
- **从**：sql执行线程——执行relay log中的语句

## 4.3 索引类型

	- 普通索引
	- 唯一索引：索引列的值必须唯一，但允许有空值
	- 主键索引：特殊的唯一索引，一个表只能有一个主键，不允许有空值
	- 组合索引：在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合
	- 全文索引：主要用来查找文本中的关键字（MATCH AGAINST）
	- Mysql8新特性降序索引

## 4.4 聚集索引（主键索引）和非聚集索引

-  MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址
- innodb中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引
- innodb的非聚集索引的叶子节点上的data是主键。（为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证）

## 4.5 存储引擎

- MyISAM： 
  - 拥有较高的插入，查询速度
  - 不支持事务
  - 支持表级锁
  - 不支持MVCC
  - 不支持外键
  - 支持全文索引
  - 内部维护了一个计数器，selectcount更快
- InnoDB ：插入缓冲（insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead)
  - 5.5版本后Mysql的默认数据库
  - 支持ACID事务
  - 支持行级锁定
  - 支持MVCC
  - 支持外键
  - 不支持全文索引
  - 不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
  - 不建议用非单调的字段作为主键：因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。
  - 特殊的功能“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引（B+Tree 索引具有哈希索引的一些优点）

## 4.6 索引数据结构

### 4.6.1 B+Tree 索引

- MySQL 存储引擎的默认索引类型
- BTREE 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问
- B-tree 索引可以用于使用 =, >, >=, <, <= 或者 BETWEEN 运算符的列比较
- B+ Tree 的有序性，可以用于排序和分组
- InnoDB 的 B+Tree 索引分为主索引和辅助索引
  - 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引（一个表只有一个：数据行不能存放个）
  - 辅助索引的叶子节点的 data 域记录着主键的值。使用辅助索引进行查找，先查找主键值，再到主索引中进行查找
- MyISAM的 B+Tree 索引分为主索引和辅助索引
  - 和InnoDB不同，data域保存数据记录的地址
  - 主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复

### 4.6.2 Hash 索引

- 检索效率非常高，索引的检索可以一次定位
- 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
- 无法用于排序与分组
- Hash 索引不能利用部分索引键查询。
- Hash 索引在任何时候都不能避免表扫描。
- Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

## 4.7 索引优化

- 独立的列：索引列不能是表达式的一部分，也不能是函数的参数
- 多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好
- 索引列的顺序：让选择性（不重复的索引值和记录总数的比值）最强的索引列放在前面
- 前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符
- 覆盖索引：索引包含所有需要查询的字段的值

## 4.8 事务的实现

- 事务的**原子性**是通过 undo log（回滚日志） 来实现的
- 事务的**持久性**是通过 redo log（重做日志） 来实现的
- 事务的**隔离性**是通过 (读写锁+MVCC)来实现的
- 事务的**一致性**是通过原子性，持久性，隔离性来实现的

![image-20210315163259110](/Users/lv/Library/Application Support/typora-user-images/image-20210315163259110.png)

## 4.9 AUTOCOMMIT

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

## 4.10 mysql锁技术

- 读写锁
- 共享锁(shared lock),又叫做"读锁
- 排他锁(exclusive lock),又叫做"写锁"

## 4.11 MVCC基础

MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制

```
InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列， 一个保存了行的创建时间，一个保存了行的过期时间， 当然存储的并不是实际的时间值，而是系统版本号。
```

通过**数据多版本**来做到**读写分离**。从而实现不加锁读进而做到读写并行

## 4.12 并发一致性问题

- 丢失修改：一个事务的更新操作被另外一个事务的更新操作替换
- 脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据
- 不可重复读：一个事务内多次读取同一数据集合
- 幻读：针对插入语句，一个update，一个insert，update之后发现有未更新数据

## 4.13 事务的隔离级别

级别由低到高

- **READ UNCOMMITED** (未提交读) ：事务中的修改，即使没有提交，对其它事务也是可见的（读的过程中写，脏读，**读写并行**）
- **READ COMMITED** (提交读)：一个事务只能读取已经提交的事务所做的修改（排它锁，**读写分离机制**，产生**不可重读**以及**幻读**问题）
- **REPEATABLE READ** (可重复读)（默认级别）：保证在同一个事务中多次读取同一数据的结果是一样的（**读写锁实现**or**MVCC实现**）
- **SERIALIZABLE** (串行)

![image-20210315164122553](/Users/lv/Library/Application Support/typora-user-images/image-20210315164122553.png)

## 4.14 查询性能优化

- 使用 Explain分析SELECT语句
  - select_type : 查询类型，有简单查询、联合查询、子查询等
  - key : 使用的索引
  - rows : 扫描的行数
- 优化数据访问
  - 减少请求的数据量
    - 只返回必要的列：最好不要使用 SELECT * 语句。
    - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
    - 缓存重复查询的数据
  - 减少服务器端扫描的行数：索引
- 重构查询方式
  - 切分大查询
  - 分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联

## 4.15 组合索引

- 组合索引遵循最左前缀原则，建立（a,b,c）索引等于建立了（a），（a，b），（a，b，c）
- 组合索引的字段出现在where条件中，or的条件无法使用索引
- 遇到范围查询时停止匹配（like、between、<、>）
- (a,b)建立索引，a=x时，b相对有序（全局无序）

# 五、缓存淘汰策略LRU

Least Recently Used

- 如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。
- 哈希表+双向链表实现
- 使用哈希表存储 **key**，值为链表中的节点，节点中存储值，双向链表来记录节点的顺序，头部为最近访问节点。
- **`LRU`**算法中有两种基本操作
  - **`get(key)`**：查询key对应的节点，如果key存在，将节点移动至链表头部。
  - **`set(key, value)`**： 设置key对应的节点的值。如果key不存在，则新建节点，置于链表开头。如果链表长度超标，则将处于尾部的最后一个节点去掉。如果节点存在，更新节点的值，同时将节点置于链表头部。

# 六、高并发架构

关键字：分布式、高可用、集群、负载均衡、正/反代理

## 6.1 演进

1. 应用与数据库分离：增加服务器资源，提高性能
2. 本地缓存和分布式缓存：使用memcached作为本地缓存，使用Redis作为分布式缓存，减小数据库的压力
3. 反向代理（Nginx）实现负载均衡
4. 数据库的读写分离
5. 数据分库（按业务）
6. 把大表拆分为小表
7. 使用LVS或F5来使多个Nginx负载均衡(四层的负载均衡解决方案)
8. 通过DNS轮询实现机房间的负载均衡
9. 引入NoSQL数据库和搜索引擎等技术
10. 大应用拆分为小应用
11. 复用的功能抽离成微服务
12. 引入企业服务总线ESB屏蔽服务接口的访问差异
13. 引入容器化技术实现运行环境隔离与动态服务管理
14. 以云平台承载系统

# 七、数据库分库分表

## 7.1 方式

- 垂直分表（大表拆小表）：将不经常使用或者长度较大的字段拆分出去放到“扩展表”中（设计阶段考虑）
- 垂直分库：按照业务模块来划分出不同的数据库
- 水平分表（横向分表）：降低单表数据量，优化查询性能（主键hash或取模）
- 水平分库分表：水平分表+分库

## 7.2 产生的问题和解决思路

- 垂直分库->跨库Join
  - 全局表
  - 字段冗余（数据一致性的问题）
  - 数据同步
  - 系统层组装
- 水平分库
  - 分布式全局唯一ID
  - 分片规则
    - 随机分片和连续分片
  - 数据迁移，容量规划，扩容等问题
  - 跨分片的排序分页（分别排序之后汇总再排序）
  - 跨分片的函数处理
  - 夸分片join

# 八、微服务

## 8.1 服务治理

### 8.1.1 服务注册与发现

**why**

- 服务之间相互调用，就需要知道对方的 IP 和端口。
- 在没有注册中心的情况下，每个服务会将其他服务的 IP 和端口写死在自己的配置文件里
- 这样的话，每次需要新增或移除一个服务实例的时候，相关联的所有服务都需要修改配置。
- 随着服务越来越多，服务实例的新增或移除越来越频繁，依然靠人工手动写配置和变更配置，对运维和开发来说简直就是灾难

**how**

- **服务注册**:每一个服务实例在启动运行的时候，都将自己的信息（包括 IP、端口和唯一的服务名字等）上报给注册中心，注册中心则会将所有服务注册的信息保存到注册表中
- **服务发现**:服务 A 需要调用服务 B 时，服务 A 里配置的是服务 B 的名字，服务 A 会根据服务 B 的名字向注册中心请求服务 B 的实例信息，从而拿到服务 B 的 IP 地址和端口
- 服务 B 如果存在多个实例，那注册中心返回的可能就是服务 B 的实例信息列表，这时，服务 A 则可以选用某种负载均衡算法取得其中一个 IP，再进行调用。有些注册中心自身也提供了负载均衡算法，直接算好一个 IP 并返回，则无需服务 A 自己选择
- 服务注册与发现还有一个重要的功能就是可以自动监控管理服务器的存活状态。主要实现方式就是注册中心与每个服务器之间定时发送**心跳包**，做健康检查

### 8.1.2 服务配置

**why**

- 各个服务各自管理自己的配置参数
- 配置文件可能还使用不同格式
- 对配置项的命名规则也可能不一样
- 如果参数需要修改，也很不灵活，甚至还要重启运行中的服务才能生效
- 一个服务还会部署多个实例，那该服务的配置参数需要修改的时候，所有实例也都要同步修改和重启
- 项目中都会有多个环境：**测试环境、UAT 环境、生产环境**等

### 8.1.3 熔断

- 被调用方故障，调用方会主动停止调用
- 通过熔断器实现，熔断器主要有三种状态：
  - **closed**：关闭状态，让请求通过的默认状态。如果请求错误率低于阈值，则状态保持不变。可能出现的错误是超过最大并发数和超时错误。
  - **open**：当熔断器打开的时候，所有的请求都会被标记为失败。这是故障快速失败机制，而不需要等待超时时间完成。
  - **half open**：半开状态时，会定期的尝试发起请求来确认系统是否恢复。如果恢复了，熔断器将转为关闭状态或者保持打开
- 状态转换：
  - 最开始处于 closed 状态，一旦检测到错误率到达一定阈值，便转为 open 状态；
  - 这时候会有个 reset timeout，到了这个时间了，会转移到 half open 状态；
  - 尝试放行一部分请求到目标服务，一旦检测成功便回归到 closed 状态，即恢复服务；
- 检测错误率的实现原理也比较简单，主要就是在一个滑动时间窗口内，统计下调用目标服务接口的总请求数和错误的请求数，一旦错误率达到设置的阀值，就触发熔断
- 在这个滑动时间窗口内，应该还有个最小请求数的设置，比如 10s 内至少要有 20 次请求，如果没达到最小请求数，就算失败率达到了阀值也不触发熔断，否则，很大可能会造成误杀

![image-20210511155044120](/Users/lv/Library/Application Support/typora-user-images/image-20210511155044120.png)

注：**限流和熔断都是为了保护当前服务自身的可用性，但限流是为了防止上游服务调用量过大从而压垮当前服务，熔断则是为了避免下游服务出现故障时引发级联故障**

### 8.1.4 限流

- 请求数量超出服务的处理能力时，会自动丢弃新来的请求。
- 核心指标可能是 QPS、总并发数、并发线程数，甚至是 IP 白名单
- 常见的限流算法有四种：**计数器算法、滑动窗口算法、漏桶算法、令牌桶算法**
  - **计数器算法**
    - **计数器算法**，也称为**固定窗口算法**
    - 在固定的时间周期内（即时间窗口）累加访问次数
    - 当达到设定的阀值时，触发限流策略，比如拒绝请求
    - 下一个周期开始时，进行清零，重新计数
    - 存在一个严重的问题，那就是**临界问题**
  - **滑动窗口算法**
    - 将一个时间窗口进行分割，比如将 1 分钟的时间窗口分割成 6 格，则每格代表 10 秒钟
    - 每一格都有自己独立的计数器
    - 每过 10 秒钟，就把整个 1 分钟的时间窗口往右滑动 1 格
    - 时间窗口内的总计数，则是将该窗口内的所有格子的计数总和出来的
  - **漏桶算法**
    - 把系统看成一个水桶，进来的请求理解为往桶里注水，处理请求就是桶中的水流出
    - 水桶有固定容量，如果满了就溢出。不管注入水（请求进入）的快慢如何，只按照恒定的速率出水（处理请求）
    - 因为桶容量是不变的，保证了整体的速率
    - 速率是固定的，应对突发流量时效率低
  - **令牌桶算法**
    - 令牌以一定的速度生成并放入桶中，达到桶容量时停止生成
    -  请求发生时，先从桶中获取令牌，获取到令牌的请求进行业务处理
    - 未获取到令牌的请求返回失败
    - 通过调整令牌的放入速率应对突发流量的场景
- 限流的使用场景：对接口做限流（主要是客户端 API 和开放 API 则需要做限流，管理端 API、服务内部 API一般无需）
  - 开放 API 的限流规则应该严格，因为更容易被攻击
  - 限流规则的粒度方面，除了需要限制集群整体的访问频率，还需要限制某类接口甚至某个具体接口的访问频率。网关层的限流只能做到粗粒度的集群整体的限流，以及按不同路由名称进行限流。而具体到某个接口的，则只能在业务层的微服务进行限流了，所以还需要给对应的微服务集成限流组件客户端。具体接口层面，应该对下单请求进行限流，而限流策略可以用匀速器方式，对应的则是漏桶算法

### 8.1.5 降级

通过开关配置将某些不重要的业务功能屏蔽掉，以提高服务处理能力

- **关闭次要服务**：在服务压力过大时，关闭非核心功能的服务，避免核心功能被拖垮。比如，淘宝双11活动当天，订单量激增，为了保证核心的交易业务的高可用，就会暂时关闭非核心的退货服务。
- **丢弃部分请求**：对于一些老请求——即从接收到处理的时间已经超过了一定时间（比如1s）的请求，可以直接丢弃。还可以根据请求的优先级，有选择性地丢弃那些优先级低的请求。或者随机丢弃一定比例的请求。
- **读降级**：对于读一致性要求不高的场景，在服务和数据库压力过大时，可以不读数据库，降级为只读缓存数据，以这种方式来减小数据库压力，提高服务的吞吐量。
- **写降级**：在服务压力过大时，可以将同步写转为异步写，来减小服务压力并提高吞吐量。既然把同步改成了异步也就意味着降低了数据一致性，保证数据最终一致即可。
- **屏蔽写入**：很多高并发场景下，查询请求都会走缓存，这时数据库的压力主要是写入压力。所以对于某些不重要的服务，在服务和数据库压力过大时，可以关闭写入功能，只保留查询功能，这样可以明显减小数据库压力。
- **数据冗余**：服务调用者可以冗余它所依赖服务的数据。当依赖的服务故障时，服务调用者可以直接使用冗余数据。

## 8.2 数据一致性

![image-20210329144930038](/Users/lv/Library/Application Support/typora-user-images/image-20210329144930038.png)

### 8.2.1 可靠事件通知模式

异步事件通知－外部事件服务

- 业务服务在提交前，向事件服务发送事件，事件服务只记录事件，并不发送
- 业务服务在提交或回滚后通知事件服务，事件服务发送事件或者删除事件
- 事件服务会定时获取所有仍未发送的事件并且向业务系统查询，根据业务系统的返回来决定发送或者删除该事件

**注意事项**（保证事件消费的`幂等性`）

- 事件本身是具备幂等性的状态型事件
  - 如订单状态的通知（已下单、已支付、已发货等），则需要判断事件的顺序。
  - 一般通过时间戳来判断，既消费过了新的消息后，当接受到老的消息直接丢弃不予消费。
  - 如果无法提供全局时间戳，则应考虑使用全局统一的序列号
- 不具备幂等性的事件
  - 一般是动作行为事件，如扣款100，存款200，则应该将事件id及事件结果持久化
  - 在消费事件前查询事件id，若已经消费则直接返回执行结果；
  - 若是新消息，则执行，并存储执行结果

![image-20210329143854987](/Users/lv/Library/Application Support/typora-user-images/image-20210329143854987.png)

### 8.2.2 最大努力通知模式

- 业务服务在提交事务后，进行有限次数（设置最大次数限制）的消息发送，比如发送三次消息，若三次消息发送都失败，则不予继续发送
- 主业务方需要提供查询接口给从业务服务，用来恢复丢失消息
- 对于时效性保证比较差（既可能会出现较长时间的软状态），所以对于数据一致性的时效性要求比较高的系统无法使用

### 8.2.3 业务补偿模式

- 补偿模式要求每个服务都提供补偿借口，且这种补偿一般来说是`不完全补偿`
- 既即使进行了补偿操作，那条取消的火车票记录还是一直存在数据库中可以被追踪（一般是有相信的状态字段“已取消”作为标记）
- 业务在调用的时候正常提交，当一个服务失败的时候，所有其依赖的上游服务都进行业务补偿操作

### 8.2.4 TCC/Try Confirm Cancel模式

- Try，业务服务完成所有的业务检查，预留必需的业务资源
- 如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；
- 否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。

![image-20210329145428019](/Users/lv/Library/Application Support/typora-user-images/image-20210329145428019.png)

# 九、计算机网络

![image-20210315154739460](/Users/lv/Library/Application Support/typora-user-images/image-20210315154739460.png)

- IP协议：一种分组交换传输协议；
- TCP协议：一种面向连接，可靠传输的协议；
- UDP协议：一种无连接，不可靠传输的协议。
- 操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序
- 一个Socket由IP地址和端口号
- 小于1024的端口属于*特权端口*，需要管理员权限
- 使用Socket进行网络编程时，本质上就是两个进程之间的网络通信
- 服务器端的Socket是指定的IP地址和指定的端口号；客户端的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号
- 三次握手
  - TCP客户端最后还要发送一次确认的原因：主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误
- 四次挥手
  - A 发送连接释放报文，FIN=1。
  - B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
  - 当 B 不再需要连接时，发送连接释放报文，FIN=1。
  - A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
  - B 收到 A 的确认后释放连接。
- underlay就是底层承载网，overlay就是基于底层网络互联互通的基础加上隧道技术去构建一个虚拟的网络。overlay的核心其实就是打隧道（tunnel）

## 9.1 HTTP

### 9.1.1 URL

- HTTP 使用 URL（ **U** niform **R**esource **L**ocator，统一资源定位符）来定位资源，它是 URI（**U**niform **R**esource **I**dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。

### 9.1.2 HTTP状态码

![image-20210315160509284](/Users/lv/Library/Application Support/typora-user-images/image-20210315160509284.png)

### 9.1.3 短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

### 9.1.4 http1.x和http2.0

#### 9.1.4.1 HTTP/1.x

- **缺陷**：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞

**http1.0**

- **缺陷**：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（T**CP连接的新建成本很高，因为需要客户端和服务器三次握手**），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；
- **解决方案**：
  - 添加头信息——非标准的Connection字段`Connection: keep-alive`

**http1.1**

- **改进点：**

1. **持久连接**
   - 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`(对于同一个域名，大多数浏览器允许同时建立6个持久连接)
2. **管道机制**
   - 即在同一个TCP连接里面，客户端可以同时发送多个请求。
3. **分块传输编码**
   - 即服务端每产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。
4. **新增请求方式**
   - PUT:请求服务器存储一个资源;
   - DELETE：请求服务器删除标识的资源；
   - OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；
   - TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；
   - CONNECT：保留将来使用

- **缺点：**
  - 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行**的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”
  - **避免方式：**一是减少请求数，二是同时多开持久连接

#### 9.1.4.2 HTTP/2.0

**特点**

1. 采用二进制格式而非文本格式；
2. 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；
3. 使用报头压缩，降低开销
4. 服务器推送

**①二进制协议**

- HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。
- 二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

**②完全多路复用**

- HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。

③报头压缩**

- HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。
- 对于相同的头部，不必再通过请求发送，只需发送一次；
- HTTP/2 对这一点做了优化，引入了头信息压缩机制；
- 一方面，头信息使用gzip或compress压缩后再发送；
- 另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

**④服务器推送**

- HTTP/2 允许服务器未经请求，主动向客户端发送资源；
- 通过推送那些服务器任务客户端将会需要的内容到客户端的缓存中，避免往返的延迟

## 9.2 Cookie

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）

### 9.2.1 用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 9.2.2 创建过程

- 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。
- 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

### 9.2.3 分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

## 9.2 Session

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

## 9.3 HTTPS

### 9.3.1 工作机制

- 客户端发起一个http请求，连接到服务器的443端口。
- 服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。
- 验证证书的合法性：客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。
- 生成随机密码（RSA签名）：如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。
- 生成对称加密算法：验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。

### 9.3.2 https的优点

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

![image-20210315162007751](/Users/lv/Library/Application Support/typora-user-images/image-20210315162007751.png)

### 9.3.2 HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

# 十、Redis

## 10.1 数据类型

- 键的类型只能为字符串
- 值支持五种数据类型：
  - 字符串：
    - `set <key> <value>`
    - `get <key>`
    - `del <key>`
  - 列表
    - `rpush <key> <item>`
    - `lrange <key> i j`（j可填-1）
    - `rindex <key> i`
    - `lpop <key>`
  - 无序集合
    - `sadd <key> <item>`
    - `smembers <key>`
    - `sismember <key> <item>`
    - `srem <key> <item>`
  - 散列表
    - `hset <key> <sub_key> <value>`
    - `hgetall <key>`（每条数据sub_key和value各占一行）
    - `hdel <key> <sub_key>`
  - 有序集合
    - `zadd <key> <score> <item>`
    - `zrange <key> i j withscores`
    - `zrangebyscore <key> <score1> <score2>  withscores`
    - `zrem <key> <item>`

![image-20210317103340705](/Users/lv/Library/Application Support/typora-user-images/image-20210317103340705.png)

## 10.2 使用场景

- 计数器：对 String 进行自增自减运算，从而实现计数器功能（Redis 这种内存型数据库的读写性能非常高）
- 缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率
- 查找表：查找表的内容不能失效（DNS）
- 消息队列：List 是一个双向链表
- 会话缓存
- 分布式锁实现
  - SETNX
  - RedLock
- 其他
  - SET可以实现交集、并集等操作
  - ZSet 可以实现有序性操作

## 10.3 分布式锁实现

### 10.3.1 SETNX

set if not exists(redis单例)

- SETNX lock.foo <current Unix time + lock timeout + 1>
- 如果 SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）
- 如果 SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁
- 解决死锁问题
  - SETNX lock.foo 返回0，获取锁失败
  - GET lock.foo 来检测锁是否已超时
  - GETSET lock.foo <current Unix timestamp + lock timeout + 1>
  - 设置键的值的同时，还会返回键的旧值
  - 通过比较键 lock.foo 的旧值是否小于当前时间，可以判断进程是否已获得锁

### 10.3.2 RedLock

- 客户端获取当前的时间戳。
- 对 N 个 Redis 实例进行获取锁的操作，具体的操作同单机分布式锁。对 Redis 实例的操作时间需要远小于分布式锁的超时时间，这样可以保证在少数 Redis 节点 Down 掉的时候仍可快速对下一个节点进行操作。
- 客户端会记录所有实例返回加锁成功的时间，只有从多半的实例（在这里例子中 >= 3）获取到了锁，且操作的时间远小于分布式锁的超时时间，锁才被人为是正确获取。
- 如果锁被成功获取了，当前分布式锁的合法时间为初始设定的合法时间减去上锁所花的时间。
- 若分布式锁获取失败，会强制对所有实例进行锁释放的操作，即使这个实例上不存在相应的键值

## 10.4 Redis 与 Memcached

- 两者都是非关系型内存键值数据库
- 差异
  - 数据类型：
    - Memcached 仅支持字符串类型
    - Redis 支持五种不同的数据类型
  - 数据持久化
    - Redis 支持两种持久化策略：RDB 快照和 AOF 日志
    -  Memcached 不支持持久化
  - 分布式
    - Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。
    - Redis Cluster 实现了分布式的支持
  - 内存管理机制
    - 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中
    - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了

## 10.5 数据淘汰策略

![image-20210317143713858](/Users/lv/Library/Application Support/typora-user-images/image-20210317143713858.png)

## 10.6 缓存穿透与缓存雪崩

- 缓存穿透：用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询
  - 布隆过滤器：对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询
  - 缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源
- 缓存雪崩：大量key同一时间点失效，同时又有大量请求打进来，导致流量直接打在DB上，造成DB不可用
  - 设置key永不失效（热点数据）；
  - 设置key缓存失效时候尽可能错开；
  - 使用多级缓存机制，比如同时使用redsi和memcache缓存，请求->redis->memcache->db；
  - redis高可用

## 10.7 集群模式

### 10.7.1 主从复制

#### 10.7.1.1 原理

1. slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令
2. master将保存的快照文件发送给slave，并继续记录执行的写命令
3. slave接收到快照文件后，加载快照文件，载入数据
4. master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化
5. 此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性

#### 10.7.1.2 优/缺点

- 优点
  - master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
  - master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
- 缺点
  - 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
  - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
  - 难以支持在线扩容，Redis的容量受限于单机配置



![image-20210413113922535](/Users/lv/Library/Application Support/typora-user-images/image-20210413113922535.png)

### 10.7.2 Sentinel（哨兵）模式

哨兵模式基于主从复制模式，引入了哨兵来监控与自动处理故障

#### 10.7.2.1 功能

- 监控master、slave是否正常运行
- 当master出现故障时，能自动将一个slave转换为master
- 多个哨兵可以监控同一个Redis，哨兵之间也会自动监控

#### 10.7.2.2 工作机制

- 哨兵节点配置master的信息（多个、IP/端口）
- 哨兵与master建立两条连接：
  - 一条连接用来订阅master的`_sentinel_:hello`频道与获取其他监控该master的哨兵节点信息
  - 另一条连接定期向master发送INFO等命令获取master本身的信息
- 定期执行操作：
  - 定期（一般10s一次，当master被标记为主观下线时，改为1s一次）向master和slave发送INFO命令
  - 定期向master和slave的`_sentinel_:hello`频道发送自己的信息（哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本）
    - 其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。
    - 其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新
    - 当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。
  - 定期（1s一次）向master、slave和其他哨兵发送PING命令
- 通过发送INFO命令可以获取到slave信息（自动发现），哨兵也会与slave建立两条连接执行监控
- 故障发生：
  - 被PING的数据库或者节点超时未回复，哨兵认为其主观下线
  - 下线的是master，哨兵会向其它哨兵发送命令询问它们是否也认为该master主观下线
  - 达到一定数目（即配置文件中的quorum）投票，哨兵会认为该master已经客观下线，并选举领头的哨兵节点对主从系统发起故障恢复
  - 若没有足够的sentinel进程同意master下线，master的客观下线状态会被移除
  - 若master重新向sentinel进程发送的PING命令返回有效回复，master的主观下线状态就会被移除
- 故障恢复的操作需要由选举的领头哨兵来执行，选举采用Raft算法：
  - 发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵
  - 如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵
  - 如果有超过一半的哨兵同意选举A为领头，则A当选
  - 如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵
- 故障恢复选择新的master节点：
  - 所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置
  - 如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选
  - 如果以上条件都一样，选取id最小的slave
- 挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其升格为master，然后再向其他slave发送命令接受新的master，最后更新数据。
- 将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。

10.7.2.3 优/缺点

- 优点：
  - 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
  - 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
- 缺点：
  - 同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置
  - 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务

![image-20210413114448140](/Users/lv/Library/Application Support/typora-user-images/image-20210413114448140.png)

### 10.7.3 Cluster模式

- Cluster模式实现了Redis的分布式存储（无中心结构），即每台节点存储不同的内容，来解决在线扩容的问题
- Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用
- 不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。

#### 10.7.3.1 特点

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
- 节点的fail是通过集群中超过半数的节点检测失效时才生效
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

#### 10.7.3.2 工作机制

- 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
- 当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作
- 为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
- 当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

#### 10.7.3.3 优/缺点

- 优点：
  - 无中心架构，数据按照slot分布在多个节点。
  - 集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。
  - 可线性扩展到1000多个节点，节点可动态添加或删除
  - 能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换
- 缺点：
  - 客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”
  - 节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的
  - 数据通过异步复制，不保证数据的强一致性
  - slave充当“冷备”，不能缓解读压力
  - 批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好
  - key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能
  - 不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0

![image-20210413165257265](/Users/lv/Library/Application Support/typora-user-images/image-20210413165257265.png)

# 十一、容器

## 11.1 Docker

### 11.1.1 网络模式

Docker使用Linux的Namespaces技术来进行资源隔离

- host模式：容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口
- container模式：指定新创建的容器和已经存在的一个容器共享一个Network Namespace，新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等
- none模式：Docker容器拥有自己的Network Namespace，但不为Docker容器进行任何网络配置，没有网卡、IP、路由等信息
- bridge模式：默认模式，为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上
  - 当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥
  - 选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用

![image-20210317145603531](/Users/lv/Library/Application Support/typora-user-images/image-20210317145603531.png)

## 11.2. k8s

### 11.2.1 组件

- 主节点（Master）：kube-controller-manager，kube-apiserver，kube-scheduler
- 工作节点（Node）：kubelet和kube-proxy
- 只有apiserver使用etcd

### 11.2.2 滚动升级

- Deployment已经内置了RollingUpdate strategy
- 升级的过程是先创建新版的pod将流量导入到新pod上后销毁原来的旧的pod
- StatefulSet
  - 默认方式
    - 从序号最大的 Pod 开始，逐个删除和更新每一个 Pod，直到序号最小的 Pod 被更新
    - 当正在更新的 Pod 达到了 Running 和 Ready 的状态之后，才继续更新其前序 Pod
  - 指定 `.spec.updateStrategy.rollingUpdate.partition` 字段，可以分片（partitioned）执行RollingUpdate 更新策略
    - 序号大于或等于 .spec.updateStrategy.rollingUpdate.partition 的 Pod 将被删除重建
    - 序号小于 .spec.updateStrategy.rollingUpdate.partition 的 Pod 将不会更新，及时手工删除该 Pod，kubernetes 也会使用前一个版本的 .spec.template 重建该 Pod
    - 如果 .spec.updateStrategy.rollingUpdate.partition 大于 .spec.replicas，更新 .spec.tempalte 将不会影响到任何 Pod
  - partition适用场景
    - 预发布
    - 金丝雀更新
    - 按阶段的更新

### 11.2.3 亲和、反亲和

- 亲和性：应用A与应用B两个应用频繁交互，所以有必要利用亲和性让两个应用的尽可能的靠近，甚至在一个node上，以减少因网络通信而带来的性能损耗。
- 反亲和性：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，以提高HA。
- node亲和性可以约束调度器基于node labels调度pod
  - requiredDuringSchedulingIgnoredDuringExecution：严格执行，满足规则调度，否则不调度
  - preferredDuringSchedulingIgnoredDuringExecution：尽力执行，优先满足规则调度

# 十二、消息中间件

低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一

## 1.1 组成

- **Broker**：消息服务器，作为server提供消息核心服务
- **Producer**：消息生产者，业务的发起方，负责生产消息传输给broker
- **Consumer**：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理
- **Topic**：主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的 广播
- **Queue**：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
- **Message**：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输

## 12.2 模式

### 12.2.1 点对点（PTP）

使用queue作为通信载体 

![image-20210413104125222](/Users/lv/Library/Application Support/typora-user-images/image-20210413104125222.png)

### 12.3.2 Pub/Sub发布订阅（广播）

：使用topic作为通信载体

![image-20210413104255405](/Users/lv/Library/Application Support/typora-user-images/image-20210413104255405.png)

## 12.3 常用消息中间件

- RocketMQ
- RabbitMQ
- kafka
- ActiveMQ

### 12.3.1 对比

![消息中间件MQ详解及四大MQ比较3](https://res-static.hc-cdn.cn/fms/img/42e69ee21f15f67b9c307adc3395e28b1603442336104)

## 12.4 Rabbitmq集群

- Erlang 编写的，Erlang 天生支持分布式（通过同步 Erlang 集群各节点的 cookie 来实现）
- 元数据：队列、交换器、绑定、vhost
- 默认情况下，集群中唯一节点来负责任何特定队列，其它节点上只存储了特定队列所有者节点的指针
- 内存节点与磁盘节点：内存节点恢复故障可以从磁盘节点上恢复元数据（集群至少1个磁盘节点，2 台以上的磁盘节点满足高可用）
- 镜像队列（ha-all策略）：发布消息时，路由到主队列中，而主队列通过类似广播的机制，将消息扩散同步至其余从队列中（主队列发生故障重新选主）

# 十三、负载均衡



# 十四、进程、线程



## 14.1 进程间通信方式

进程间的通信主要包括管道，系统IPC（包括消息队列，信号量，共享存储），SOCKET

- 管道包括三种：
  - 普通管道PIPE，通常会有限制，一是半双工，只能单向传输，二是只能在斧子进程之间使用
  - 流管道s_pipe，去除了第一种限制，可以双线传输
  - 命名管道：name_pipe，去除了第二种限制，可以在许多不相关的进程之间进行通讯
- 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子关系
- 有名管道：是半双工的方式，但是允许无亲缘关系的进程之间的通信。
- 信号量：是一个计数器，可以用来控制多个进程对共享资源的访问通常作为一种锁机制，防止某进程正在访问共享资源的时候，其他进程也访问该资源。因此作为一种进程间以及同一进程内不同线程之间的同步手段
- 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标示符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点 
- 信号：信号是一种比较复杂的通信方式，用于通知接收进程所访问的内存
- 共享内存：共享内存是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程可以访问，共享内存是最快的IPC方式，是针对其他进程间通信方式运行效率低而专门设计的，往往与其他通信机制，如信号量配合使用，来实现进程间的相互通信
- 套接字：套接口也是一种进程间的通信机制，与其他通信机制不同的是，可以用于不同及其间的进程

14.2 

# 十五、一致性hash算法

## 15.1 背景

- 分布式缓存：不同的服务器存储不通对象的数据
- 实现缓存的负载均衡：m = hash(o) mod n
- 取模的问题：扩缩容服务器时，n的变化导致m变化出现缓存访问不命中

## 15.2 原理

### 15.2.1 一致性Hash环

- 环的起点是0，终点是2^32-1
- 起点和终点连接
- 中间的整数按逆时针分布

### 15.2.2 过程

1. 将对象放置到Hash环：m = hash(o)，hash值范围0~2^32-1
2. 将机器放置到Hash环：t = hash(c)，使用相同的hash函数计算机器的hash值
3. 为对象选择机器：顺时针查找距离对象hash值最近的机器（即对象所属机器）
4. 处理机器增减的情况：增加机器时，只需调整增加机器的hash值到前一个机器hash值之间的数据

### 15.2.3 虚拟节点

- 新加入的节点只能分担一台机器的负载，效率不够
- 引入虚拟节点，将物理服务器虚拟为一组虚拟机器
- 将虚拟机器计算hash放入hash环
- 先确定对象的虚拟机器，再确定虚拟机器对应的物料服务器

![image-20210511104951851](/Users/lv/Library/Application Support/typora-user-images/image-20210511104951851.png)

# 十六、位运算

## 16.1 "异或运算"（XOR）

### 16.1.1 含义

- XOR 主要用来判断两个值是否不同
-  一般使用插入符号（caret）`^`表示
- 约定`0` 为 false，`1` 为 true

### 16.1.2 运算定律

- 一个值与自身的运算，总是为 false：x ^ x = 0
- 一个值与 0 的运算，总是等于其本身：x ^ 0 = x
- 可交换性： x ^ y = y ^ x
- 结合性：x ^ (y ^ z) = (x ^ y) ^ z

### 16.1.3 应用

①交换值

```java
int x=2, y =3;
x = x^y; //x=2^3,y=3
y = x^y; //x=2^3,y=2^3^3=2
x = x^y; //x=2^3^2=3, y=2
```

注：这是两个变量交换值的最快方法，不需要任何额外的空间。

②加密

1. 明文（text）与密钥（key）进行异或运算，可以得到密文（cipherText）`text ^ key = cipherText`
2. 密文与密钥再次进行异或运算，就可以还原成明文 `cipherText ^ key = text`

③数据备份

- 文件 x 和文件 y 进行异或运算，产生一个备份文件 z。
- 无论是文件 x 或文件 y 损坏，只要不是两个原始文件同时损坏，就能根据另一个文件和备份文件，进行还原

